from flask import Blueprint, request, jsonify
from app.services.auth_service import auth_service
from app.services.security_service import security_service
from app.utils.decorators import require_telegram_auth
from app.models.database import db_manager
from app.config.settings import Config
from datetime import datetime
import logging

logger = logging.getLogger(__name__)
channels_bp = Blueprint('channels', __name__)


@channels_bp.route('/search', methods=['POST'])
@require_telegram_auth
def search_channel():
    """Поиск канала через Telegram API"""
    try:
        data = request.get_json()
        if not data or 'username' not in data:
            return jsonify({'success': False, 'error': 'Username обязателен'}), 400

        username = data['username'].strip().lstrip('@')
        user_id = auth_service.get_current_user_id()

        # Здесь должен быть вызов Telegram API
        # Пока возвращаем заглушку
        return jsonify({
            'success': True,
            'channel': {
                'id': f'fake_id_{username}',
                'username': username,
                'title': f'Канал @{username}',
                'description': 'Описание канала',
                'subscribers_count': 1000,
                'verified': False
            },
            'user_permissions': {
                'is_admin': True
            }
        })

    except Exception as e:
        logger.error(f"Search channel error: {e}")
        return jsonify({
            'success': False,
            'error': 'Внутренняя ошибка сервера'
        }), 500


@channels_bp.route('', methods=['POST'])
@require_telegram_auth
def add_channel():
    """Добавление канала с автоматической модерацией"""
    try:
        data = request.get_json()
        if not data:
            return jsonify({'success': False, 'error': 'JSON data required'}), 400

        username = data.get('username', '').strip()
        telegram_user_id = auth_service.get_current_user_id()

        if not username:
            return jsonify({'success': False, 'error': 'Username обязателен'}), 400

        # Получаем или создаем пользователя
        user_db_id = db_manager.ensure_user_exists(telegram_user_id)

        if not user_db_id:
            return jsonify({'success': False, 'error': 'Ошибка создания пользователя'}), 500

        cleaned_username = username.lstrip('@')

        # Проверяем, не добавлен ли уже канал
        existing_channel = db_manager.execute_query("""
                                                    SELECT c.id, c.title
                                                    FROM channels c
                                                             JOIN users u ON c.owner_id = u.id
                                                    WHERE c.username = ?
                                                      AND u.telegram_id = ?
                                                    """, (cleaned_username, telegram_user_id), fetch_one=True)

        if existing_channel:
            return jsonify({
                'success': False,
                'error': f'Канал @{cleaned_username} уже добавлен вами'
            })

        # === ГЕНЕРАЦИЯ КОДА ВЕРИФИКАЦИИ ===
        import string
        import random
        import secrets

        def generate_verification_code():
            """Генерация уникального кода верификации в формате #add123abc"""
            chars = string.ascii_lowercase + string.digits
            random_part = ''.join(random.choices(chars, k=6))
            return f"#add{random_part}"

        verification_code = generate_verification_code()

        # === ДОБАВЛЯЕМ КАНАЛ В БАЗУ С КОДОМ ВЕРИФИКАЦИИ ===
        current_time = datetime.now().isoformat()

        channel_id = db_manager.execute_query("""
                                              INSERT INTO channels (telegram_id, username, title, description, owner_id,
                                                                    category, created_at, verification_code, status)
                                              VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
                                              """, (
                                                  f'fake_id_{cleaned_username}',
                                                  cleaned_username,
                                                  data.get('title', f'Канал @{cleaned_username}'),
                                                  data.get('description', ''),
                                                  user_db_id,
                                                  data.get('category', 'general'),
                                                  current_time,
                                                  verification_code,
                                                  'pending_verification'
                                              ))

        if channel_id:
            logger.info(
                f"✅ Channel @{cleaned_username} added with verification code {verification_code} for user {telegram_user_id}")

            # === ВОЗВРАЩАЕМ ОТВЕТ С ИНСТРУКЦИЯМИ ПО АВТОМАТИЧЕСКОЙ МОДЕРАЦИИ ===
            return jsonify({
                'success': True,
                'message': f'Канал @{cleaned_username} добавлен! Для подтверждения отправьте код {verification_code} в канал.',
                'verification_code': verification_code,
                'verification_instructions': f'''Для автоматического подтверждения канала:

1. Скопируйте код: {verification_code}
2. Отправьте его в ваш Telegram канал @{cleaned_username}
3. Система автоматически подтвердит канал в течение 1-2 минут

Код должен быть отправлен именно в том канале, который вы добавляете.
После отправки кода канал будет автоматически верифицирован.''',
                'channel': {
                    'id': channel_id,
                    'username': cleaned_username,
                    'title': data.get('title', f'Канал @{cleaned_username}'),
                    'subscribers_count': 1000,
                    'status': 'pending_verification',
                    'verification_code': verification_code,
                    'is_verified': False
                }
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Канал не был добавлен в базу данных'
            })

    except Exception as e:
        logger.error(f"Ошибка добавления канала: {e}")
        return jsonify({
            'success': False,
            'error': f'Ошибка сервера: {str(e)}'
        }), 500


@channels_bp.route('/my', methods=['GET'])
@require_telegram_auth
def get_my_channels():
    """Получение моих каналов"""
    try:
        telegram_user_id = auth_service.get_current_user_id()

        user_db_id = db_manager.ensure_user_exists(telegram_user_id)
        if not user_db_id:
            return jsonify({
                'success': False,
                'channels': [],
                'total': 0,
                'message': 'Ошибка пользователя'
            }), 500

        # Получаем каналы пользователя
        channels = db_manager.execute_query("""
                                            SELECT c.*, u.username as owner_username, u.telegram_id as owner_telegram_id
                                            FROM channels c
                                                     JOIN users u ON c.owner_id = u.id
                                            WHERE c.owner_id = ?
                                              AND u.telegram_id = ?
                                            ORDER BY c.created_at DESC
                                            """, (user_db_id, telegram_user_id), fetch_all=True)

        if not channels:
            return jsonify({
                'success': True,
                'channels': [],
                'total': 0,
                'message': 'У вас пока нет добавленных каналов'
            })

        # Обогащаем данные каналов
        enriched_channels = []
        for channel in channels:
            channel_data = dict(channel)

            # Обеспечиваем совместимость полей
            if 'subscriber_count' not in channel_data:
                channel_data['subscriber_count'] = channel_data.get('subscribers_count', 0)

            # Форматируем дату
            if channel_data.get('created_at'):
                try:
                    created_at = datetime.fromisoformat(channel_data['created_at'].replace('Z', '+00:00'))
                    channel_data['created_at_formatted'] = created_at.strftime('%d.%m.%Y')
                except:
                    channel_data['created_at_formatted'] = 'Неизвестно'

            enriched_channels.append(channel_data)

        # Статистика
        stats = {
            'total_channels': len(enriched_channels),
            'verified_channels': len([c for c in enriched_channels if c.get('is_verified')]),
            'active_channels': len([c for c in enriched_channels if c.get('is_active')]),
            'total_subscribers': sum(c.get('subscriber_count', 0) or 0 for c in enriched_channels)
        }

        return jsonify({
            'success': True,
            'channels': enriched_channels,
            'total': len(enriched_channels),
            'stats': stats
        })

    except Exception as e:
        logger.error(f"Ошибка получения каналов: {e}")
        return jsonify({
            'success': False,
            'channels': [],
            'error': str(e)
        }), 500


@channels_bp.route('/<int:channel_id>', methods=['DELETE'])
@require_telegram_auth
def delete_channel(channel_id):
    """Удаление канала"""
    try:
        telegram_user_id = auth_service.get_current_user_id()

        # Проверяем права на удаление
        channel = db_manager.execute_query('''
                                           SELECT c.id, c.title, c.username
                                           FROM channels c
                                                    JOIN users u ON c.owner_id = u.id
                                           WHERE c.id = ?
                                             AND u.telegram_id = ?
                                           ''', (channel_id, telegram_user_id), fetch_one=True)

        if not channel:
            return jsonify({
                'success': False,
                'error': 'Канал не найден или у вас нет прав на его удаление'
            }), 404

        # Удаляем канал
        result = db_manager.execute_query('''
                                          DELETE
                                          FROM channels
                                          WHERE id = ?
                                          ''', (channel_id,))

        if result is not None:
            logger.info(f"Канал {channel_id} удален пользователем {telegram_user_id}")
            return jsonify({
                'success': True,
                'message': f'Канал @{channel["username"]} удален'
            })
        else:
            return jsonify({
                'success': False,
                'error': 'Ошибка удаления канала'
            }), 500

    except Exception as e:
        logger.error(f"Ошибка удаления канала: {e}")
        return jsonify({'success': False, 'error': str(e)}), 500


def telegram_webhook():
    """Webhook для автоматической верификации каналов"""
    try:
        from datetime import datetime
        from app.models.database import db_manager
        import logging
        
        logger = logging.getLogger(__name__)
        data = request.get_json()
        
        if not data:
            return jsonify({'ok': True})
        
        logger.info(f"📨 Webhook получен: {data.get('update_id', 'N/A')}")
        
        # Обрабатываем сообщения в каналах
        if 'channel_post' in data:
            message = data['channel_post']
            chat = message.get('chat', {})
            chat_id = str(chat.get('id'))
            text = message.get('text', '')
            
            logger.info(f"📢 Сообщение из канала {chat_id}: {text[:50]}...")
            
            # Ищем каналы с кодами верификации
            channels = db_manager.execute_query("""
                SELECT id, username, verification_code, telegram_id
                FROM channels 
                WHERE status = 'pending_verification' 
                AND verification_code IS NOT NULL
            """, fetch_all=True)
            
            if channels:
                logger.info(f"🔍 Найдено {len(channels)} каналов на проверке")
                
                verification_found = False
                
                for channel in channels:
                    verification_code = channel['verification_code']
                    if verification_code and verification_code in text:
                        # Подтверждаем канал
                        success = db_manager.execute_query("""
                            UPDATE channels 
                            SET status = 'verified', verified_at = ?, is_verified = 1
                            WHERE id = ?
                        """, (datetime.now().isoformat(), channel['id']))
                        
                        if success:
                            logger.info(f"✅ Канал {channel['username']} автоматически верифицирован с кодом {verification_code}!")
                            verification_found = True
                        else:
                            logger.error(f"❌ Ошибка обновления канала {channel['id']}")
                
                if verification_found:
                    logger.info("🎉 Верификация успешно завершена!")
                else:
                    logger.info("ℹ️ Код верификации не найден в сообщении")
            else:
                logger.info("ℹ️ Нет каналов ожидающих верификации")
        
        return jsonify({'ok': True})
        
    except Exception as e:
        logger = logging.getLogger(__name__)
        logger.error(f"❌ Ошибка webhook: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'ok': True})  # Всегда возвращаем ok для Telegram

        logger.info(f"📨 Webhook получил данные: {data}")

        # Обрабатываем только сообщения в каналах
        if 'channel_post' in data:
            message = data['channel_post']
            chat = message.get('chat', {})
            chat_id = str(chat.get('id'))
            text = message.get('text', '')
            chat_username = chat.get('username', '')

            logger.info(f"📺 Сообщение из канала {chat_username or chat_id}: {text[:100]}...")

            # Ищем каналы, ожидающие верификации
            pending_channels = db_manager.execute_query("""
                                                        SELECT id, username, verification_code, title
                                                        FROM channels
                                                        WHERE status = 'pending_verification'
                                                          AND verification_code IS NOT NULL
                                                        """, fetch_all=True)

            if not pending_channels:
                logger.info("🔍 Нет каналов, ожидающих верификации")
                return jsonify({'ok': True})

            # Проверяем каждый канал на наличие его кода в сообщении
            for channel in pending_channels:
                verification_code = channel['verification_code']
                channel_username = channel['username']

                # Проверяем совпадение по username или содержанию кода
                username_match = (chat_username and chat_username.lower() == channel_username.lower())
                code_in_text = verification_code in text

                if code_in_text and (username_match or chat_username == channel_username):
                    # АВТОМАТИЧЕСКАЯ ВЕРИФИКАЦИЯ
                    current_time = datetime.now().isoformat()

                    update_result = db_manager.execute_query("""
                                                             UPDATE channels
                                                             SET status      = 'verified',
                                                                 is_verified = 1,
                                                                 verified_at = ?
                                                             WHERE id = ?
                                                             """, (current_time, channel['id']))

                    if update_result:
                        logger.info(
                            f"✅ Канал @{channel_username} автоматически верифицирован! Код: {verification_code}")

                        # Опционально: отправляем уведомление пользователю
                        # send_verification_notification(channel['id'], channel_username)

                    else:
                        logger.error(f"❌ Ошибка верификации канала @{channel_username}")

                elif code_in_text:
                    logger.warning(
                        f"⚠️ Код {verification_code} найден, но канал не совпадает. Ожидался @{channel_username}, получен @{chat_username}")

        # Обрабатываем обычные сообщения (если бот добавлен в канал как админ)
        elif 'message' in data:
            message = data['message']
            chat = message.get('chat', {})

            # Проверяем, что это сообщение из канала
            if chat.get('type') in ['channel', 'supergroup']:
                chat_id = str(chat.get('id'))
                text = message.get('text', '')
                chat_username = chat.get('username', '')

                logger.info(f"💬 Сообщение из группы/канала {chat_username or chat_id}: {text[:100]}...")

                # Аналогичная логика проверки кодов
                pending_channels = db_manager.execute_query("""
                                                            SELECT id, username, verification_code, title
                                                            FROM channels
                                                            WHERE status = 'pending_verification'
                                                              AND verification_code IS NOT NULL
                                                            """, fetch_all=True)

                for channel in pending_channels:
                    verification_code = channel['verification_code']
                    channel_username = channel['username']

                    username_match = (chat_username and chat_username.lower() == channel_username.lower())
                    code_in_text = verification_code in text

                    if code_in_text and username_match:
                        current_time = datetime.now().isoformat()

                        update_result = db_manager.execute_query("""
                                                                 UPDATE channels
                                                                 SET status      = 'verified',
                                                                     is_verified = 1,
                                                                     verified_at = ?
                                                                 WHERE id = ?
                                                                 """, (current_time, channel['id']))

                        if update_result:
                            logger.info(
                                f"✅ Канал @{channel_username} автоматически верифицирован через сообщение! Код: {verification_code}")

        return jsonify({'ok': True})

    except Exception as e:
        logger.error(f"❌ Ошибка webhook: {e}")
        import traceback
        logger.error(f"Traceback: {traceback.format_exc()}")
        # Всегда возвращаем ok для Telegram, чтобы избежать повторных отправок
        return jsonify({'ok': True})


def send_verification_notification(channel_id, channel_username):
    """
    Отправляет уведомление пользователю об успешной верификации
    (опциональная функция для будущего расширения)
    """
    try:
        # Здесь можно добавить логику отправки уведомлений
        # через Telegram бота или внутреннюю систему уведомлений
        logger.info(f"📧 Уведомление о верификации канала @{channel_username} отправлено")
    except Exception as e:
        logger.error(f"❌ Ошибка отправки уведомления: {e}")

@channels_bp.route('/webhook', methods=['POST'])
def telegram_webhook():
    """Webhook для автоматической верификации каналов"""
    try:
        from datetime import datetime
        import logging

        logger = logging.getLogger(__name__)
        data = request.get_json()

        if not data:
            return jsonify({'ok': True})

        logger.info(f"📨 Webhook получен: {data.get('update_id', 'N/A')}")

        # Обрабатываем сообщения в каналах
        if 'channel_post' in data:
            message = data['channel_post']
            chat = message.get('chat', {})
            chat_id = str(chat.get('id'))
            text = message.get('text', '')

            logger.info(f"📢 Сообщение из канала {chat_id}: {text[:50]}...")

            # Ищем каналы с кодами верификации
            channels = db_manager.execute_query("""
                SELECT id, username, verification_code, telegram_id
                FROM channels 
                WHERE status = 'pending_verification' 
                AND verification_code IS NOT NULL
            """, fetch_all=True)

            if channels:
                logger.info(f"🔍 Найдено {len(channels)} каналов на проверке")

                verification_found = False

                for channel in channels:
                    verification_code = channel['verification_code']
                    if verification_code and verification_code in text:
                        # Подтверждаем канал
                        db_manager.execute_query("""
                            UPDATE channels 
                            SET status = 'verified', verified_at = ?, is_verified = 1
                            WHERE id = ?
                        """, (datetime.now().isoformat(), channel['id']))

                        logger.info(f"✅ Канал {channel['username']} автоматически верифицирован с кодом {verification_code}!")
                        verification_found = True

                if verification_found:
                    logger.info("🎉 Верификация успешно завершена!")
                else:
                    logger.info("ℹ️ Код верификации не найден в сообщении")
            else:
                logger.info("ℹ️ Нет каналов ожидающих верификации")

        return jsonify({'ok': True})

    except Exception as e:
        logger = logging.getLogger(__name__)
        logger.error(f"❌ Ошибка webhook: {e}")
        import traceback
        traceback.print_exc()
        return jsonify({'ok': True})
